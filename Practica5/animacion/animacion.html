<!DOCTYPE HTML>
<html>

<head>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden;
      display: block;
    }

    #gui {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>WebGL 2.0</title>
</head>

<body>
  <canvas id="webglcanvas" style="border: none;" width="676" height="324"></canvas>
  <img src="fondo4.jpg" id="fondo" hidden />
  <img src="ninja.png" id="d1" hidden />
  <img src="salto.png" id="d2" hidden />
  <img src="ninjaizq.PNG" id="d3" hidden />
  <img src="bandera2.png" id="d4" hidden />
  <img src="vida.webp" id="d5" hidden />
  <img src="Coin.png" id="d6" hidden />
  <img src="detenido.png" id="d7" hidden />
  <img src="ninjaizq.PNG" id="d8" hidden />
  <img src="dama.png" id="d9" hidden />
  <img src="ataque.png" id="d10" hidden />

  <script id="vs" type="vertex">
    #version 300 es
    precision mediump float;
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    uniform mat4 uMatrizTextura;
    layout(location = 0) in vec2 aVertices;
    layout(location = 1) in vec2 aCoordenadasDeTextura;
    out vec2 vCoordenadasDeTextura;
    void main() {
      vCoordenadasDeTextura = (uMatrizTextura * vec4(aCoordenadasDeTextura, 0.0, 1.0)).xy;
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision mediump float;
    uniform sampler2D uUnidadDeTextura;
    in vec2 vCoordenadasDeTextura;
    out vec4 color;
    void main() {
      color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
    }
  </script>

  <script>

    "use strict";

    function toRadians(grados) {
      return grados * Math.PI / 180;
    };

    /* Matriz Identidad */
    function identidad(r) {
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /* Traslación - glTranslatef */
    function traslacion(matriz, tx, ty, tz) {
      let r = new Array(16);
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Escalación - glScalef */
    function escalacion(matriz, sx, sy, sz) {
      let r = new Array(16);
      r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre X - glRotatef */
    function rotacionX(matriz, theta) {
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = c; r[9] = -s; r[13] = 0;
      r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre Y - glRotatef */
    function rotacionY(matriz, theta) {
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = 0; r[8] = s; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre Z - glRotatef */
    function rotacionZ(matriz, theta) {
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = -s; r[8] = 0; r[12] = 0;
      r[1] = s; r[5] = c; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Proyección Paralela - glOrtho */
    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2 / (der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq) / (der - izq);
      r[1] = 0; r[5] = 2 / (arr - abj); r[9] = 0; r[13] = -(arr + abj) / (arr - abj);
      r[2] = 0; r[6] = 0; r[10] = -2 / (lejos - cerca); r[14] = -(lejos + cerca) / (lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /* Multiplicación de matrices de 4 x 4 */
    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
          r[i + j * 4] = s;
        }
      }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }
    var gl, canvas, programaID;
    var texturaFondo, texturad1, texturad2, texturad3, texturad4, texturad5, texturad6, texturad7, texturad8, texturad9, texturad10;
    var codigoFondo, codigod1, codigod2, codigod3, codigod4, codigod5, codigod6, codigod7, codigod8, codigod9, codigod10;
    var uMatrizProyeccion, uMatrizVista, uMatrizModelo, uUnidadDeTextura, uMatrizTextura;
    var MatrizProyeccion = new Array(16), MatrizVista = new Array(16),
      MatrizModelo = new Array(16), MatrizTextura = new Array(16);

    let inicio = Date.now();
    let inicio2 = Date.now();

    let tiempoMovimiento = 0.1;
    const PERIODO_MOVIMIENTO = 0.1;

    const PERIODO_MOVIMIENTO_PUNTOS = 0.15;
    let tiempoMovimientoPuntos = PERIODO_MOVIMIENTO_PUNTOS;

    const PERIODO_MOVIMIENTO_DEMONIO = 0.12;
    let tiempoMovimientoDemonio = PERIODO_MOVIMIENTO_DEMONIO;

    const PERIODO_MOVIMIENTO_BANDERA = 0.12;
    let tiempoMovimientoBandera = PERIODO_MOVIMIENTO_BANDERA;

    let v = 3;
    let dt = 0, dts = 0, dtq = 0, bt = 0, pt = 0, mt = 0, ft = 0;
    const gravedad = -0.02;
    const salto = 0.6;
    let velX = 0.01;
    let velY = 0;
    let velXsalto = 0.02;
    let tx = -8, ty = -1;
    let iniciado = false;
    let perdiste = false;
    let posInicialX = -8;
    let posInicialY = -1;
    let ganaste = false;
    let moviendoDerecha = false;
    let moviendoIzquierda = false;
    let saltando = false;

    let atacando = false;
    let duracionAtaque = 0.3;
    let tiempoAtaque = 0;

    let atacandoDemonio = false;
    let demonioVisible = true;
    const posDemonio = [-0.5, 4.6]; // posición actual del demonio

    const suelos = [
      [-10, -5.5, -1.3],
      [-5, -2.2, 1.6],
      [-1.5, 1.5, 4.3],
      [2.2, 3, 2],
      [4, 5, 0.4],
      [5.5, 10, 0.5],

    ];


    function moverHaciaDemonio(tiempo_real) {
      const velocidadAtaque = 2.0; // velocidad de movimiento hacia el demonio
      let dx = posDemonio[0] - tx;
      let dy = posDemonio[1] - ty;
      let distancia = Math.sqrt(dx * dx + dy * dy);

      if (distancia > 0.05) {
        // mueve al personaje hacia el demonio
        tx += dx / distancia * velocidadAtaque * tiempo_real;
        ty += dy / distancia * velocidadAtaque * tiempo_real;
        // animación de caminar hacia el demonio
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 1, 1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dt, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod1); // textura caminar derecha
        texturad1.muestra(gl);

        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dt += 1 / 5;
          if (dt > 1 / 4) dt = 0;
        }
      } else {
        // llegó al demonio -> ataca
        atacandoDemonio = true;
        atacando = true;
      }
    }

    function dibujaSuelo() {
      gl.bindTexture(gl.TEXTURE_2D, null);
      for (let i = 0; i < suelos.length; i++) {
        let s = suelos[i];
        let x1 = s[0];
        let x2 = s[1];
        let y = s[2];
        let suelo = new Rectangulo(gl, x1, y, x2, y + 0.2);
        identidad(MatrizModelo);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
        suelo.muestra(gl);
      }
    }

    function reiniciarJuego() {
      v--; // reducir vida
      if (v <= 0) {
        alert("Juego terminado! Puntaje final: " + scoreActual);
        v = 3; // reiniciar vidas
        scoreActual = 0; // reiniciar score
      }
      //actualizarVida();
      tx = posInicialX;
      ty = posInicialY;
      velY = 0;
      velX = 0.01;
      perdiste = false;

      inicio = Date.now();
      requestAnimationFrame(personaje);
    }


    window.addEventListener("keydown", function (e) {
      if (perdiste && e.code === "Enter") {
        reiniciarJuego();
      }
    });

    function enSuelo(x, y) {
      for (let i = 0; i < suelos.length; i++) {
        let s = suelos[i];
        if (x >= s[0] && x <= s[1]) {
          // Si está ligeramente por encima del suelo, o un poco dentro del bloque, ajustamos
          if (y <= s[2] + 0.5 && y >= s[2] - 0.5) {
            return s[2]; // devuelve la altura del suelo
          }
        }
      }
      return null;
    }



    function compilaEnlazaLosShaders() {
      const shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shaderDeVertice));

      const shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shaderDeFragmento));

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice);
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(programaID));
    }

    class Rectangulo {
      constructor(gl, x1, y1, x2, y2, u1, v1, u2, v2) {
        const vertices = new Float32Array([x1, y1, x2, y1, x2, y2, x1, y2]);
        const coord_textura = new Float32Array([u1, v1, u2, v1, u2, v2, u1, v2]);
        this.rectanguloVAO = gl.createVertexArray();
        gl.bindVertexArray(this.rectanguloVAO);

        let bufferV = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferV);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        let bufferT = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferT);
        gl.bufferData(gl.ARRAY_BUFFER, coord_textura, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      muestra(gl) {
        gl.bindVertexArray(this.rectanguloVAO);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.bindVertexArray(null);
      }
    }

    function leeLaTextura(ID, tex) {
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      let img = document.getElementById(ID);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }

    function muestraFondo() {
      identidad(MatrizTextura);
      gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
      identidad(MatrizModelo);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
      gl.bindTexture(gl.TEXTURE_2D, codigoFondo);
      texturaFondo.muestra(gl);
    }

    function bandera() {
      identidad(MatrizModelo);
      traslacion(MatrizModelo, 8, 1, 0);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      identidad(MatrizTextura);
      traslacion(MatrizTextura, bt, 0, 0);
      gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

      gl.activeTexture(gl.TEXTURE0);
      gl.uniform1i(uUnidadDeTextura, 0);
      gl.bindTexture(gl.TEXTURE_2D, codigod4);

      texturad4.muestra(gl);

      let fin2 = Date.now();
      let duracion2 = fin2 - inicio2;
      inicio2 = fin2;
      let tiempo_real2 = duracion2 / 1000.0;
      tiempoMovimientoBandera -= tiempo_real2;

      if (tiempoMovimientoBandera < 0.001) {
        tiempoMovimientoBandera = PERIODO_MOVIMIENTO_BANDERA;
        bt += 1 / 4;
        if (bt > 3 / 4) bt = 0;
      }


    }


    let pt1 = 0;
    let pt2 = 0;
    let pt3 = 0;
    let pt4 = 0;
    let pt5 = 0;
    let pt6 = 0;
    const posPunto1 = [1, 4.8];
    const posPunto2 = [2.5, 2.5];

    const posPunto3 = [4.2, 0.5];
    const posPunto4 = [-9, -1];

    const posPunto5 = [-4, 2];
    const posPunto6 = [-3, 2];
    let tiempoMovimientoPuntos1 = PERIODO_MOVIMIENTO_PUNTOS;
    let tiempoMovimientoPuntos2 = PERIODO_MOVIMIENTO_PUNTOS;
    let tiempoMovimientoPuntos3 = PERIODO_MOVIMIENTO_PUNTOS;
    let tiempoMovimientoPuntos4 = PERIODO_MOVIMIENTO_PUNTOS;
    let tiempoMovimientoPuntos5 = PERIODO_MOVIMIENTO_PUNTOS;
    let tiempoMovimientoPuntos6 = PERIODO_MOVIMIENTO_PUNTOS;

    let puntos = [
      { pos: [posPunto1[0], posPunto1[1]], anim: pt1, tiempo: tiempoMovimientoPuntos1, visible: true },
      { pos: [posPunto2[0], posPunto2[1]], anim: pt2, tiempo: tiempoMovimientoPuntos2, visible: true },
      { pos: [posPunto3[0], posPunto3[1]], anim: pt3, tiempo: tiempoMovimientoPuntos3, visible: true },
      { pos: [posPunto4[0], posPunto4[1]], anim: pt4, tiempo: tiempoMovimientoPuntos4, visible: true },
      { pos: [posPunto5[0], posPunto5[1]], anim: pt5, tiempo: tiempoMovimientoPuntos5, visible: true },
      { pos: [posPunto6[0], posPunto6[1]], anim: pt6, tiempo: tiempoMovimientoPuntos6, visible: true }
    ];

    function verificarColisiones() {
      const radio = 0.5; // distancia para “recoger” el punto
      for (let i = 0; i < puntos.length; i++) {
        if (!puntos[i].visible) continue;

        let dx = tx - puntos[i].pos[0];
        let dy = ty - puntos[i].pos[1];
        let distancia = Math.sqrt(dx * dx + dy * dy);

        if (distancia < radio) {
          puntos[i].visible = false;
          scoreActual++; // sumar 1 al puntaje
          //alert("¡Recogiste el punto " + (i + 1) + "!");
        }
      }
    }

    function dibujarPuntos(tiempo_real) {
      for (let i = 0; i < puntos.length; i++) {
        if (!puntos[i].visible) continue;

        identidad(MatrizModelo);
        traslacion(MatrizModelo, puntos[i].pos[0], puntos[i].pos[1], 0);
        escalacion(MatrizModelo, 0.5, 0.5, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, puntos[i].anim, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uUnidadDeTextura, 0);
        gl.bindTexture(gl.TEXTURE_2D, codigod6);
        texturad6.muestra(gl);

        puntos[i].tiempo -= tiempo_real;
        if (puntos[i].tiempo < 0.001) {
          puntos[i].tiempo = PERIODO_MOVIMIENTO_PUNTOS;
          puntos[i].anim += 1 / 4;
          if (puntos[i].anim > 3 / 4) puntos[i].anim = 0;
        }
      }
    }

    let acumuladorDemonio = 0;

    function demonio(deltaTime) {
      if (!demonioVisible) return;

      identidad(MatrizModelo);
      traslacion(MatrizModelo, posDemonio[0], posDemonio[1], 0);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      identidad(MatrizTextura);
      traslacion(MatrizTextura, mt, 0, 0);
      gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, codigod9);
      texturad9.muestra(gl);

      acumuladorDemonio += deltaTime;
      if (acumuladorDemonio > PERIODO_MOVIMIENTO_DEMONIO) {
        acumuladorDemonio = 0;
        mt += 1 / 4;
        if (mt > 3 / 4) mt = 0;
      }
    }



    let scoreActual = 0; // puntaje actual

    function score() {
      const espacio = 0.8; // separación entre puntos
      for (let i = 0; i < scoreActual; i++) { // dibuja solo los puntos recogidos
        identidad(MatrizModelo);
        traslacion(MatrizModelo, -9 + i * espacio, 8, 0);
        escalacion(MatrizModelo, 0.7, 0.7, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uUnidadDeTextura, 0);
        gl.bindTexture(gl.TEXTURE_2D, codigod6); // textura de coin/punto
        texturad6.muestra(gl);
      }
    }

    function vida() {
      const espacio = 1.0;
      for (let i = 0; i < 3; i++) {
        identidad(MatrizModelo);
        traslacion(MatrizModelo, -9 + i * espacio, 9, 0); // ajustar posiciones
        escalacion(MatrizModelo, 0.7, 0.7, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uUnidadDeTextura, 0);
        gl.bindTexture(gl.TEXTURE_2D, codigod5); // textura del corazón

        texturad5.muestra(gl);
      }
    }
    function actualizarVida() {
      texturad5 = new Rectangulo(gl, -2, -1, 1, 1, 0, 0, v, 1);

    }


    function personaje() {
      gl.clear(gl.COLOR_BUFFER_BIT);
      let fin = Date.now();
      let duracion = fin - inicio;
      inicio = fin;
      let tiempo_real = duracion / 1000.0;
      tiempoMovimiento -= tiempo_real;
      dibujarPuntos(tiempo_real);
      verificarColisiones();
      muestraFondo();
      bandera();
      vida();
      //barra();
      score();
      dibujarPuntos(tiempo_real);
      verificarColisiones();
      //puntos();
      //dibujaSuelo();
      demonio(tiempo_real);
      velY += gravedad;
      ty += velY;

      // Verificar si está sobre el suelo
      let sueloActual = enSuelo(tx, ty);

      if (sueloActual !== null) {
        ty = sueloActual;
        velY = 0;
      }

      // Movimiento horizontal controlado por teclas
      if (moviendoDerecha) {
        tx += velX;
      }

      if (moviendoIzquierda) {
        tx -= velX;
      }


      if (velY !== 0) {
        tx += velX + velXsalto;
        // Animación salto / caída
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 1, 1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dts, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod2);
        texturad2.muestra(gl);

        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dts += 1 / 9;
          if (dts > 8 / 9) dts = 0;
        }

      } else if (moviendoDerecha) {
        // Animación caminar derecha
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 1, 1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dt, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod1);
        texturad1.muestra(gl);

        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dt += 1 / 5;
          if (dt > 1 / 4) dt = 0;
        }

      }
      else if (moviendoIzquierda) {
        // Animación caminar izquierda
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 1, 1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dt, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod8);
        texturad8.muestra(gl);

        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dt += 1 / 5;
          if (dt > 1 / 4) dt = 0;
        }

      }
      else if (atacandoDemonio && demonioVisible) {
        moverHaciaDemonio(tiempo_real);
      } else if (atacando) {
        // animación ataque normal
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 1, 1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dt, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod10);
        texturad10.muestra(gl);

        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dt += 1 / 12;
          if (dt > 5 / 6) {
            dt = 0;
            atacando = false;
            atacandoDemonio = false;
            demonioVisible = false; // desaparece el demonio
          }
        }
      }
      else {
        // Animación quieto
        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, 0.8, 0.8, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        identidad(MatrizTextura);
        traslacion(MatrizTextura, dtq, 0, 0);
        gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, codigod7);
        texturad7.muestra(gl);
        if (tiempoMovimiento < 0.001) {
          tiempoMovimiento = PERIODO_MOVIMIENTO;
          dtq += 1 / 4;
          if (dtq > 1 / 3) dtq = 0;
        }
      }

      // Si se cae por debajo de un límite -> pierde
      if (ty < -10) {
        perdiste = true;

      }
      requestAnimationFrame(personaje);
    }

    function main() {
      canvas = document.getElementById("webglcanvas");
      gl = canvas.getContext("webgl2");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (!gl) { document.write("WebGL 2.0 no disponible"); return; }
      gl.viewport(0, 0, canvas.width, canvas.height);
      compilaEnlazaLosShaders();

      texturaFondo = new Rectangulo(gl, -10, -10, 10, 10, 0, 0, 1, 1);
      codigoFondo = gl.createTexture();
      leeLaTextura("fondo", codigoFondo);

      texturad1 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 5, 1);
      codigod1 = gl.createTexture();
      leeLaTextura("d1", codigod1);

      texturad2 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 9, 1);
      codigod2 = gl.createTexture();
      leeLaTextura("d2", codigod2);

      texturad3 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 5, 1);
      codigod3 = gl.createTexture();
      leeLaTextura("d3", codigod3);

      texturad4 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 4, 1);
      codigod4 = gl.createTexture();
      leeLaTextura("d4", codigod4);

      texturad5 = new Rectangulo(gl, -0.5, -0.5, 1, 1, 0, 0, 1, 1);
      codigod5 = gl.createTexture();
      leeLaTextura("d5", codigod5);

      texturad6 = new Rectangulo(gl, -0.5, -0.5, 1, 1, 0, 0, 1 / 4, 1);
      codigod6 = gl.createTexture();
      leeLaTextura("d6", codigod6);

      texturad7 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 4, 1);
      codigod7 = gl.createTexture();
      leeLaTextura("d7", codigod7);

      texturad8 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 5, 1);
      codigod8 = gl.createTexture();
      leeLaTextura("d8", codigod8);


      texturad9 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 4, 1);
      codigod9 = gl.createTexture();
      leeLaTextura("d9", codigod9);

      texturad10 = new Rectangulo(gl, -0.1, -1, 1, 1, 0, 0, 1 / 7, 1);
      codigod10 = gl.createTexture();
      leeLaTextura("d10", codigod10);


      gl.useProgram(programaID);
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      uUnidadDeTextura = gl.getUniformLocation(programaID, "uUnidadDeTextura");
      uMatrizTextura = gl.getUniformLocation(programaID, "uMatrizTextura");

      ortho(MatrizProyeccion, -10, 10, -10, 10, -1, 1);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      identidad(MatrizVista);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.clearColor(0, 0, 1, 1);


      personaje();

    }

    // Cuando presionas una tecla
    window.addEventListener("keydown", function (e) {
      if (e.code === "ArrowRight") {
        moviendoDerecha = true;
      }
      if (e.code === "ArrowLeft") {
        moviendoIzquierda = true;
      }
      if ((e.code === "Space" || e.code === "ArrowUp") && velY === 0) {
        velY = salto; // Salta solo si está en el suelo
        saltando = true;
      }
      if (perdiste && e.code === "Enter") {
        reiniciarJuego();
      }
      if (e.code === "KeyW") {
        atacando = true;
      }

    });

    // Cuando sueltas la tecla
    window.addEventListener("keyup", function (e) {
      if (e.code === "ArrowRight") {
        moviendoDerecha = false;
      }
      if (e.code === "ArrowLeft") {
        moviendoIzquierda = false;
      }
      if (e.code === "Space" || e.code === "ArrowUp") {
        saltando = false;
      }
    });


    window.onload = main;
  </script>
</body>

</html>